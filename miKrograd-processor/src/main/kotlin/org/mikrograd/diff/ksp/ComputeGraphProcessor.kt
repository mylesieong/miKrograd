package org.mikrograd.diff.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo

// KSP Processor
class ComputeGraphProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(Mikrograd::class.qualifiedName!!)
        val invalidSymbols = symbols.filter { !it.validate() }.toList()

        symbols.filter { it is KSFunctionDeclaration && it.validate() }
            .forEach { symbol ->
                val function = symbol as KSFunctionDeclaration
                try {
                    generateComputeGraphCode(function)
                } catch (e: Exception) {
                    logger.error("Failed to process function ${function.simpleName.asString()}: ${e.message}", symbol)
                }
            }

        return invalidSymbols
    }

    private fun generateComputeGraphCode(function: KSFunctionDeclaration) {
        val packageName = function.packageName.asString()
        val fileName = "${function.simpleName.asString()}Generated"
        val fileSpec = FileSpec.builder(packageName, fileName)

        // Instead of trying to analyze the function body, we'll generate a simple hardcoded graph
        // similar to what DoubleProcessor does

        // Build the function using KotlinPoet
        val funSpec = FunSpec.builder(function.simpleName.asString() + "Generated")
            .returns(ClassName("org.mikrograd.core", "ComputeNode").parameterizedBy(DOUBLE))
            .addCode(generateHardcodedNodeCode())
            .addStatement("return multiplyNode")
            .build()

        // Write the file with imports
        fileSpec.addFileComment("Generated by ComputeGraphProcessor")
            .addImport("org.mikrograd.core", "ComputeNode", "ValueNode", "MultiplyNode")
            .addFunction(funSpec)
            .build()
            .writeTo(codeGenerator, Dependencies(false, function.containingFile!!))
    }

    private fun generateHardcodedNodeCode(): CodeBlock {
        return CodeBlock.builder()
            .addStatement("val value1 = %T(3.0).withId(%S)", ClassName("org.mikrograd.core", "ValueNode"), "const_3.0")
            .addStatement("val value2 = %T(4.0).withId(%S)", ClassName("org.mikrograd.core", "ValueNode"), "const_4.0")
            .addStatement(
                "val multiplyNode = %T<%T> { a, b -> a * b }.withId(%S)",
                ClassName("org.mikrograd.core", "MultiplyNode"),
                DOUBLE,
                "multiply_3.0_4.0"
            )
            .addStatement("multiplyNode.inputs.add(value1)")
            .addStatement("multiplyNode.inputs.add(value2)")
            .build()
    }

    companion object {
        private val DOUBLE = ClassName("kotlin", "Double")
    }
}

class ComputeGraphProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return ComputeGraphProcessor(environment.codeGenerator, environment.logger)
    }
}
