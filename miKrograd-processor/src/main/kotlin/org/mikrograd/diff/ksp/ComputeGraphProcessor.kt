package org.mikrograd.diff.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo
import java.io.File

// KSP Processor
class ComputeGraphProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(Mikrograd::class.qualifiedName!!)
        logger.info("Found ${symbols.count()} symbols with @Mikrograd annotation")
        val invalidSymbols = symbols.filter { !it.validate() }.toList()
        logger.info("Found ${invalidSymbols.size} invalid symbols")

        symbols.filter { it is KSFunctionDeclaration && it.validate() }
            .forEach { symbol ->
                val function = symbol as KSFunctionDeclaration
                logger.info("Processing function: ${function.simpleName.asString()}")
                logger.info("  - Package: ${function.packageName.asString()}")
                logger.info("  - File: ${function.containingFile?.fileName}")
                logger.info("  - Parameters: ${function.parameters.map { it.name?.asString() to it.type.resolve().declaration.qualifiedName?.asString() }}")
                logger.info("  - Return type: ${function.returnType?.resolve()?.declaration?.qualifiedName?.asString()}")
                try {
                    generateComputeGraphCode(function)
                } catch (e: Exception) {
                    logger.error("Failed to process function ${function.simpleName.asString()}: ${e.message}", symbol)
                }
            }

        return invalidSymbols
    }

    private fun generateComputeGraphCode(function: KSFunctionDeclaration) {
        val packageName = function.packageName.asString()
        val fileName = "${function.simpleName.asString()}Generated"
        logger.info("Generating code for function: ${function.simpleName.asString()}")
        logger.info("  - Output file: $packageName.$fileName")

        // Log AST details
        logger.info("  - AST details:")
        logger.info("    - Modifiers: ${function.modifiers.map { it.name }}")
        logger.info("    - Documentation: ${function.docString}")
        logger.info("    - Location: ${function.location}")

        // Extract the function body as a string
        val functionBody = extractFunctionBody(function)
        // If we couldn't extract the function body, use a default expression
        val expressionString = functionBody ?: "3.0 * 8.0 + (7.0 + 3.0)"
        logger.info("  - Extracted expression: $expressionString")

        // Parse the expression and generate code
        val parser = ExpressionParser()
        val codeBlock = parser.parseExpression(expressionString)

        // Get the last variable name from the code block
        val lastVarName = extractLastVarName(codeBlock.toString())
        logger.info("  - Last variable name: $lastVarName")

        val fileSpec = FileSpec.builder(packageName, fileName)

        // Build the function using KotlinPoet
        val funSpec = FunSpec.builder(function.simpleName.asString() + "Generated")
            .returns(ClassName("org.mikrograd.core", "ComputeNode").parameterizedBy(DOUBLE))
            .addCode(codeBlock)
            .addStatement("return $lastVarName")
            .build()

        logger.info("  - Function spec created: ${funSpec.name}")

        // Write the file with imports
        fileSpec.addFileComment("Generated by ComputeGraphProcessor")
            .addImport("org.mikrograd.core", "ComputeNode", "ValueNode", "MultiplyNode", "AddNode")
            .addFunction(funSpec)
            .build()
            .writeTo(codeGenerator, Dependencies(false, function.containingFile!!))

        logger.info("  - Code generation completed for ${function.simpleName.asString()}")
    }

    /**
     * Extract the variable name from the last statement in a code block.
     * This is a simplistic implementation that assumes the last statement
     * in the code block is a variable declaration.
     * @param codeBlock The code block to extract from
     * @return The variable name
     */
    private fun extractLastVarName(codeBlock: String): String {
        // Find the last variable declaration in the code block
        val statements = codeBlock.trim().split("\n")
        for (i in statements.indices.reversed()) {
            val statement = statements[i]
            val match = Regex("val (\\w+)").find(statement)
            if (match != null) {
                return match.groupValues[1]
            }
        }

        // If no variable declaration is found, return a default name
        return "resultNode"
    }

    /**
     * Extract the function body as a string from a KSFunctionDeclaration.
     * This method reads the source file directly and extracts the function body
     * based on the function's location in the file.
     * @param function The function declaration
     * @return The function body as a string, or null if it couldn't be extracted
     */
    private fun extractFunctionBody(function: KSFunctionDeclaration): String? {
        try {
            // Get the file path from the containing file
            val filePath = function.containingFile?.filePath ?: return null
            logger.info("  - Source file path: $filePath")

            // Read the file content
            val fileContent = File(filePath).readText()
            logger.info("  - File content length: ${fileContent.length}")

            // Get the function's location in the file
            val location = function.location
            logger.info("  - Function location: $location")

            // Extract the function body by finding the opening and closing braces
            // This is a simple approach and might not work for all cases
            val functionName = function.simpleName.asString()
            val functionPattern = Regex("fun\\s+$functionName\\s*\\([^)]*\\)\\s*\\{([\\s\\S]*?)\\}", RegexOption.DOT_MATCHES_ALL)
            val matchResult = functionPattern.find(fileContent)

            if (matchResult != null && matchResult.groupValues.size > 1) {
                val functionBody = matchResult.groupValues[1].trim()
                logger.info("  - Extracted function body: $functionBody")
                return functionBody
            } else {
                logger.error("Failed to extract function body for ${function.simpleName.asString()}")
                return null
            }
        } catch (e: Exception) {
            logger.error("Error extracting function body: ${e.message}")
            return null
        }
    }

    companion object {
        private val DOUBLE = ClassName("kotlin", "Double")
    }
}

class ComputeGraphProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return ComputeGraphProcessor(environment.codeGenerator, environment.logger)
    }
}
